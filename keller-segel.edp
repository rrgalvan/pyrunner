// Keller-Segel Italy-Spanish project

include "getARGV.idp";

verbosity = getARGV("-verb", 0);
int textVerbosity = 1;

// Mesh and finite element spaces
int nx = getARGV("-nx",40); // Number of mesh subdivisions
mesh Th = square(nx, nx, [4*x-2, 4*y-2]);

fespace Vh(Th,P1);
Vh u, u0, bu; // Solution at t_{n+1}, t_n, test function.
Vh v, v0, bv; // Solution at t_{n+1}, t_n, test function.

macro grad(u) [ dx(u), dy(u) ] // End of Macro
// Time parameters
real t = 0;
int nt = getARGV("-nt",10); // Number of time iterations
real dt = getARGV("-dt", 1.e-4); // Time step

// Keller-Segel data

real k1=0.2;
real k2=1;
real k3=0.1;
real k4=1;

real integral;

func initialU = 1.15*exp(-x^2-y^2)*(4-x^2)^2*(4-y^2)^2;
func initialU2 = 24*(((x^2-4)^2+(y^2-4)^2 + 1)-0.05*((x^2-4)^4+(y^2-4)^4));
func initialV = 0.55*exp(-x^2-y^2)*(4-x^2)^2*(4-y^2)^2;

u0 = initialU;
v0 = initialV;


// Variational problem

problem KellerSegelU(u,bu)=
int2d(Th) (
	u*bu/dt+grad(u)'*grad(bu))
- int2d(Th)(
	u0*bu/dt
	+ k1*u0*grad(v0)'*grad(bu)
	);

problem KellerSegelV(v,bv) =
	   int2d(Th)(
		  v*bv/dt
		  + k2*grad(v)'*grad(bv)
		   )
	  - int2d(Th)(
		   v0*bv/dt
		   + k4*u0*bv
		   - k3*v0*bv
		    );

// Time loop


for (int k=1; k<=nt; k++){
  t=t+dt;
  if(textVerbosity>0) cout << "Solving, iter: " << k << " (t=" << t << ")" << endl;

  KellerSegelU;
  KellerSegelV; // Solve system!
  u0 = u;  // For next iteration
  v0 = v;  // For next iteration

  plot(u, value=1, fill=1, dim=3);

  cout << "  max(u): " << u[].max << endl;
  cout << "  max(v): " << v[].max << endl;

  cout.flush;

}

